A. 已完成模块（对照 RUN_LOG 记录）

这些你们已经跑通了（我按你 RUN_LOG 的记录号对齐）：

M0 环境与最小可跑通

人话目标：服务能启动，/v1/reserve 能返回 200

证据：RUN_LOG 记录 2

M1 配额与资源忙（基础防抢）

人话目标：同 joykey 第二次 reserve → 429；同 charger 被占 → 409；stop_charging 后可再 reserve

证据：RUN_LOG 记录 3 / 4

M2 状态仓库 + 可观测快照

人话目标：/v1/snapshot 能看到 chargers / holds

证据：RUN_LOG 记录 4

M3 压测与并发一致性

人话目标：并发 reserve 不“超卖”，能自动 cleanup

证据：RUN_LOG 记录 5 / 6

M4 snapshot schema 对齐 FIELD_REGISTRY

人话目标：HoldSnapshot 新增字段默认值对齐词典

证据：RUN_LOG 记录 6

M5 词典化落地（Temporal Consistency Verification）

人话目标：新增字段必须先登记；README/代码/词典不漂移

证据：RUN_LOG 记录 7

B. 下一阶段模块路线（按 README 的“评委可见价值”排序）

下面这些是 README 里写了、但你们大概率还没全部落地的“能赢的部分”。我按最能提升 Demo 可信度的顺序排。

M6 事件列表（Dashboard 的“剧情主线”）

对应 README：6.7（/v1/incidents） + 8（UI 轮询）

人话目标

我能看到“发生了什么事”：哪些桩/哪些路段出问题了、现在处理到哪一步了。

接口口径（只用词典字段）

GET /v1/incidents（FIELD_REGISTRY：IncidentQuery / IncidentList）

Done Definition（你需要跑出来的证据）

curl 能拿到事件列表（哪怕一开始是空数组）

造一条事件后能在列表里出现（事件怎么造：会在 M7 做）

Cursor 自审重点（并发/状态机）

事件对象的字段名、枚举值：严格对齐 FIELD_REGISTRY（尤其 incident_status/incident_type）

事件查询不要“写死常量假数据”，要从 store 读

M7 阻塞上报（把“异常”变成“事件”）

对应 README：6.2（/v1/report_blocked）

人话目标

机器人说“这个桩被挡/这个路段被堵”时，系统能创建/更新一个 incident，后续才能触发 witness/视觉/工单。

接口口径（FIELD_REGISTRY）

POST /v1/report_blocked

hold_id

block_scope（CHARGER / PATH_SEGMENT）

segment_id（当 PATH_SEGMENT 必填，格式 cell_x_y）

obstacle_type（可空）

evidence_refs（可空）

返回：HTTP 204

Done Definition（证据）

先 reserve 拿到 hold_id

调 report_blocked 返回 204

再 GET /v1/incidents 能看到新增事件

Cursor 自审重点

block_scope=PATH_SEGMENT 时必须校验 segment_id 格式（但不要引入新字段）

幂等：同一个 hold_id 重复上报不要无限制造重复事件（最简单：复用同一个 incident）

M8 Witness（桩占用投票：便宜拿真相）

对应 README：3 + 6.3 + 5（触发视觉的条件）

人话目标

附近机器人来“投票”确认：这个桩到底 FREE / OCCUPIED / UNKNOWN。

投票足够清晰就别用摄像头；投票不够/冲突/超时才升级。

接口口径（FIELD_REGISTRY）

POST /v1/witness/respond

incident_id

charger_id

charger_state（FREE/OCCUPIED/UNKNOWN_OCCUPANCY）

obstacle_type（可空）

evidence_refs（可空）

points_event_id（可空，用于去重）

返回：HTTP 204

Done Definition（证据）

先用 M7 造一个 incident_id

发 3 个 witness（可以先用不同 joykey 模拟）

GET /v1/incidents 里该事件的状态/统计字段发生变化（你们可以先做最简：记录投票数与当前“领先结论”）

Cursor 自审重点（非常重要）

多样性约束：同一主体重复投票不应无限加权（哪怕先用最简：同 joykey 只计一次）

状态机不抖动：结论达到阈值后不要被少量新票轻易推翻（避免振荡）

触发升级条件要跟 README 口径一致：冲突/稀疏超时 → 视觉（M11）

M9 Witness（路段投票 + hazard 影子层）

对应 README：6.3（segment_respond）+ 7（SOFT/HARD）+ 6.6（segment_passed 边界）

人话目标

机器人对某个网格 cell 投票：PASSABLE / BLOCKED / UNKNOWN

系统把它显示在 snapshot 的 hazards 里（先当“影子提示层”），并逐步引入 SOFT/HARD 规则

接口口径（FIELD_REGISTRY）

POST /v1/witness/segment_respond

incident_id, segment_id, segment_state, evidence_refs, points_event_id

GET /v1/snapshot 输出（包含 hazards：experimental）

POST /v1/telemetry/segment_passed

注意 README 边界：它不直接改 hazard_status，只影响规划权重/轨迹展示

Done Definition（证据）

segment_respond → 204

snapshot 的 hazards 里能看到该 segment 的条目

segment_passed 上报后 UI/快照能看到“最近走通过”（哪怕先只做记录）

Cursor 自审重点

segment_passed 绝不允许解封 HARD_BLOCKED

hazard_status 与 incident_status 分清（README 明确强调过）

M10 审计账本（让评委相信“你没黑箱乱控”）

对应 README：4.2 + 6.7 + 8（UI 禁止写死 audit_status）

人话目标

系统做过哪些关键决定（改派建议/安全回退/封控/升级）都能在账本里查到。

证明：JoyGate 不对抗 OEM 安全回路。

接口口径（FIELD_REGISTRY）

GET /v1/audit/ledger

since_at, limit

输出（FIELD_REGISTRY：AuditLedgerOK）里必须包含：

audit_status

sidecar_safety_events（至少能展示事件列表；即便先是 stub）

Done Definition（证据）

做一次“模拟 sidecar 拒绝/安全回退”写入 ledger

curl /v1/audit/ledger 能看到这条记录

Cursor 自审重点

Dashboard 禁止写死 audit_status（这是 README 的硬口径）

幂等/顺序：并发写入 ledger 不丢、不乱序（最简：加锁 + append）

M11 视觉审计 stub（只在需要时触发）

对应 README：5 + 6.7（/v1/ai/vision_audit）

人话目标

当 witness 冲突/超时/高风险时，触发一次“视觉审计任务”（demo 用 stub 图片也行）

UI 能看到“已触发/已完成/失败”的状态

接口口径（FIELD_REGISTRY）

POST /v1/ai/vision_audit → 202 Accepted

输入：VisionAuditRequest（含 camera_id / incident_id 等，按词典）

输出：Accepted（ai_job_id / ai_job_status=ACCEPTED）

Done Definition（证据）

触发一次 vision_audit 返回 202

GET /v1/incidents 或 /v1/audit/ledger 能看到这次 job 的痕迹（最简：记录 job_id + 状态）

Cursor 自审重点

视觉只做 event-driven：不要搞成持续监控

阈值口径：vision_audit_threshold_low/confirm、witness_sla_timeout_minutes（README 写了）

M12 工单闭环（HARD_BLOCKED 唯一解封入口）

对应 README：6.5 + 7.2（Active Re-certification）

人话目标

HARD_BLOCKED 永不自动解封；只有专职人员工单 DONE 才能解封。

防“人忘了点 DONE”：系统可以复核/提醒/升级，但仍不自动解封。

接口口径（FIELD_REGISTRY）

POST /v1/work_orders/report → 204

work_order_id, work_order_status, segment_id/charger_id, incident_id, event_occurred_at, evidence_refs

HARD 解封规则（词典里写了）：work_order_status=DONE 才允许从 HARD → OPEN

Done Definition（证据）

先把某 segment 置为 HARD（可以通过内部测试入口或模拟流程）

工单 report(DONE) 后 snapshot hazards 里该 segment 变为 OPEN

任何“超时/复核”都不能让 HARD 自动变 OPEN（要能证明）

Cursor 自审重点（状态机大坑）

HARD_BLOCKED 永不自动解封（任何定时器都不许改 OPEN）

Active Re-certification：复核 A/B 只产生“提醒/升级/审计”，不产生解封

M13 Web UI（评委友好）

对应 README：8

人话目标

一个页面就能看到：chargers/holds、hazards 网格、incidents 列表、audit ledger（含 sidecar 安全回退）。

UI 轮询接口口径（README 已列）

/v1/snapshot

/v1/incidents

/v1/audit/ledger

Done Definition（证据）

打开 UI，刷新/轮询能看到数据变化（你用 curl 造数据，UI 反映出来）

Cursor 自审重点

UI 不能写死 audit_status

网格坐标严格展示 cell_x_y，不做几何假设（避免“网格幻觉”）